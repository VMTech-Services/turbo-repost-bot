name: turbo-repost-bot deploy

on:
  push:
    branches: [main]

concurrency:
  group: ${{ github.repository }}-${{ github.ref_name }}
  cancel-in-progress: true

env:
  REPO_NAME: turbo_repost_bot

jobs:
  analyze:
    name: üîç Analyze existing container
    runs-on: [self-hosted, windows]
    outputs:
      was-running: ${{ steps.check.outputs.running }}
    steps:
      - name: Check if container is running
        id: check
        shell: powershell
        run: |
          $name    = "${{ env.REPO_NAME }}"
          $running = if (docker ps -q -f name=$name) { 'true' } else { 'false' }
          echo "::set-output name=running::$running"
          if ($running -eq 'true') {
            Write-Host "‚úÖ Container '$name' was running before update."
          } else {
            Write-Host "‚ö†Ô∏è Container '$name' was NOT running."
          }

  teardown:
    name: üõë Teardown old container
    runs-on: [self-hosted, windows]
    needs: analyze
    if: always()   # –¥–∞–∂–µ –µ—Å–ª–∏ analyze —É–ø–∞–ª/–ø—Ä–æ–ø—É—Å—Ç–∏–ª—Å—è
    steps:
      - name: Stop & remove container
        shell: powershell
        run: |
          $name = "${{ env.REPO_NAME }}"
          if (docker ps -a -q -f name=$name) {
            Write-Host "‚èπÔ∏è Stopping and removing container '$name'..."
            docker rm -f $name
          } else {
            Write-Host "‚ÑπÔ∏è No container '$name' to remove."
          }

  delete-image:
    name: üóëÔ∏è Delete old images
    runs-on: [self-hosted, windows]
    steps:
      - name: Remove all images named $REPO_NAME
        shell: powershell
        run: |
          $name = "${{ env.REPO_NAME }}"
          $ids  = docker images -q $name
          if ($ids) {
            Write-Host "üóëÔ∏è Removing images: $ids"
            $ids | ForEach-Object { docker rmi -f $_ }
          } else {
            Write-Host "‚ÑπÔ∏è No images named '$name' found."
          }

  build-image:
    name: üõ†Ô∏è Build new Docker image
    runs-on: [self-hosted, windows]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 1

      - name: Build image with timestamp tag
        id: build
        shell: powershell
        run: |
          $repo      = "${{ env.REPO_NAME }}"
          $timestamp = (Get-Date).ToString('yyyyMMddHHmmss')
          docker build `
            -t "${repo}:latest" `
            -t "${repo}:${timestamp}" `
            .
          echo "::set-output name=tag::$timestamp"
          Write-Host "‚úÖ Built ${repo}:latest and ${repo}:${timestamp}"

  run-container:
    name: üöÄ Run new container
    runs-on: [self-hosted, windows]
    needs:
      - teardown
      - build-image
    steps:
      - name: Start container
        shell: powershell
        run: |
          $repo = "${{ env.REPO_NAME }}"
          $tag  = "${{ needs.build-image.outputs.tag }}"
          docker run -d --name $repo -e BOT_TOKEN="${{ secrets.BOT_TOKEN }}" "${repo}:${tag}"
          Write-Host "‚û°Ô∏è Container '$repo' started from image '$repo:$tag'."

  verify:
    name: ‚úîÔ∏è Verify container health
    runs-on: [self-hosted, windows]
    needs: run-container
    steps:
      - name: Wait 5s and check running state
        shell: powershell
        run: |
          $name    = "${{ env.REPO_NAME }}"
          Start-Sleep -Seconds 5
          $state   = (docker inspect -f '{{.State.Status}}' $name).Trim()
          if ($state -eq 'running') {
            Write-Host "‚úÖ Container '$name' is running."
          } else {
            Write-Error "‚ùå Container '$name' state is '$state'. Failing."
            exit 1
          }
